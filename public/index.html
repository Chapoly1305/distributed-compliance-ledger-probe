<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Unofficial DCL Network Probe</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Theme Variables */
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #238636;
            --accent-green-hover: #2ea043;
            --link-color: #484f58;
            --node-stroke: #30363d;
            --label-color: #c9d1d9;
            --label-shadow: 0 1px 3px rgba(0,0,0,0.8), 0 0 8px rgba(0,0,0,0.5);
            --overlay-bg: rgba(0,0,0,0.6);
            --graph-bg: #0d1117;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eaeef2;
            --border-color: #d0d7de;
            --text-primary: #1f2328;
            --text-secondary: #656d76;
            --text-muted: #8c959f;
            --accent-blue: #0969da;
            --accent-green: #1a7f37;
            --accent-green-hover: #2da44e;
            --link-color: #afb8c1;
            --node-stroke: #d0d7de;
            --label-color: #1f2328;
            --label-shadow: 0 1px 2px rgba(255,255,255,0.9), 0 0 4px rgba(255,255,255,0.7);
            --overlay-bg: rgba(255,255,255,0.8);
            --graph-bg: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }
        #container { display: flex; height: 100vh; }
        #sidebar {
            width: 360px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background 0.3s, border-color 0.3s;
        }
        #graph { flex: 1; position: relative; background: var(--graph-bg); transition: background 0.3s; }

        /* Header */
        .header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .header-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #58a6ff 0%, #a371f7 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .header-icon svg { width: 20px; height: 20px; fill: white; }
        h1 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .header-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .section { padding: 16px 20px; border-bottom: 1px solid var(--border-color); }
        .section h2 {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Buttons */
        button {
            background: var(--accent-green);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
            transition: background 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        button:hover { background: var(--accent-green-hover); }
        button:active { transform: scale(0.98); }
        button:disabled { background: var(--bg-tertiary); cursor: not-allowed; color: var(--text-muted); }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .btn-secondary:hover { background: var(--border-color); }

        .btn-primary-alt {
            background: var(--accent-blue);
        }
        .btn-primary-alt:hover { background: #4293e6; }

        /* Stats */
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .stat {
            background: var(--bg-primary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-blue);
            line-height: 1;
        }
        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 6px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Log */
        #log {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
            font-size: 11px;
            font-family: "SF Mono", "Fira Code", monospace;
            background: var(--bg-primary);
        }
        .log-entry {
            padding: 4px 0;
            color: var(--text-secondary);
            border-left: 2px solid transparent;
            padding-left: 8px;
            margin-left: -8px;
        }
        .log-entry.error { color: #f85149; border-left-color: #f85149; }
        .log-entry.success { color: #56d364; border-left-color: #56d364; }

        /* Node Info Panel */
        #node-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            min-width: 300px;
            max-width: 360px;
            display: none;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            backdrop-filter: blur(8px);
        }
        #node-info h3 {
            margin-bottom: 16px;
            color: var(--accent-blue);
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #node-info .type-badge {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
            text-transform: uppercase;
        }
        #node-info .row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        #node-info .row:last-child { border-bottom: none; }
        #node-info .label { color: var(--text-secondary); font-weight: 500; }
        #node-info .value { color: var(--text-primary); word-break: break-all; text-align: right; max-width: 180px; }

        /* Legend - in graph area */
        #graph-legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s, opacity 0.2s;
            user-select: none;
        }
        .legend-item:hover {
            background: var(--bg-tertiary);
        }
        .legend-item.inactive {
            opacity: 0.4;
        }
        .legend-item.inactive .legend-dot {
            opacity: 0.5;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        .legend-count {
            font-size: 10px;
            color: var(--text-muted);
            margin-left: 2px;
        }

        /* SVG and Graph */
        #graph > svg { width: 100%; height: 100%; }

        /* Inline SVG icons */
        button svg, .helper-text svg, .header-icon svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }
        .helper-text svg {
            width: 12px;
            height: 12px;
        }
        .header-icon svg {
            width: 20px;
            height: 20px;
        }
        .node { cursor: pointer; }
        .node circle {
            stroke: var(--node-stroke);
            stroke-width: 2px;
            transition: stroke-width 0.2s, filter 0.2s, r 0.3s ease-out;
        }
        .node:hover circle {
            filter: brightness(1.2);
        }
        .node text {
            font-size: 11px;
            font-weight: 500;
            fill: var(--label-color);
            pointer-events: none;
            text-shadow: var(--label-shadow);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        .node.highlighted circle {
            stroke: #f0883e;
            stroke-width: 3px;
            filter: drop-shadow(0 0 8px rgba(240, 136, 62, 0.5));
        }
        .link {
            stroke: var(--link-color);
            stroke-opacity: 0.5;
            stroke-width: 1px;
            transition: stroke 0.2s, stroke-opacity 0.2s;
        }
        .link.highlighted {
            stroke: #f0883e;
            stroke-opacity: 1;
            stroke-width: 2px;
        }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        #controls button {
            width: auto;
            padding: 8px 14px;
            font-size: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #controls button:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }
        #controls button svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        /* Watermark for PDF export */
        #watermark {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 14px;
            color: var(--text-muted);
            display: none;
            background: var(--bg-secondary);
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        /* Settings Dialog */
        #settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        #settings-dialog {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            min-width: 380px;
            max-width: 440px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 16px 48px rgba(0,0,0,0.3);
        }
        #settings-dialog h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #settings-dialog h3 svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .settings-section {
            margin-bottom: 20px;
        }
        .settings-section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
        }
        .setting-row:last-child { border-bottom: none; }
        .setting-label { color: var(--text-primary); font-size: 13px; font-weight: 500; }
        .setting-sublabel { color: var(--text-secondary); font-size: 11px; margin-top: 2px; }
        .setting-control { display: flex; align-items: center; gap: 10px; }
        .setting-control input[type="range"] {
            width: 100px;
            accent-color: var(--accent-blue);
        }
        .setting-control select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }
        .setting-value {
            color: var(--text-secondary);
            font-size: 12px;
            min-width: 45px;
            text-align: right;
            font-weight: 500;
        }
        #settings-dialog .btn-row {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }
        #settings-dialog .btn-row button {
            width: auto;
            padding: 10px 20px;
        }

        /* Inputs */
        .seed-input {
            width: 100%;
            padding: 10px 12px;
            margin-top: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 12px;
            font-family: "SF Mono", "Fira Code", monospace;
            resize: vertical;
        }
        .seed-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.2);
        }

        .helper-text {
            margin-top: 10px;
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        /* PDF Export Overlay */
        #export-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #export-dialog {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 32px;
            text-align: center;
        }
        .export-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Validator Panel */
        #validator-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            min-width: 500px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(8px);
            z-index: 100;
        }
        #validator-panel h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #validator-panel .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            width: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #validator-panel .close-btn:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        #validator-panel .summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        #validator-panel .summary-item {
            text-align: center;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        #validator-panel .summary-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-blue);
        }
        #validator-panel .summary-value.warning { color: #d29922; }
        #validator-panel .summary-value.danger { color: #f85149; }
        #validator-panel .summary-value.success { color: #56d364; }
        #validator-panel .summary-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
            text-transform: uppercase;
        }
        #validator-panel .validator-list {
            max-height: 400px;
            overflow-y: auto;
        }
        #validator-panel .validator-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s;
        }
        #validator-panel .validator-item:hover {
            background: var(--bg-tertiary);
        }
        #validator-panel .validator-item:last-child {
            border-bottom: none;
        }
        #validator-panel .validator-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        #validator-panel .validator-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        #validator-panel .validator-details {
            font-size: 11px;
            color: var(--text-secondary);
            font-family: "SF Mono", monospace;
        }
        #validator-panel .validator-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #validator-panel .status-badge {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
            text-transform: uppercase;
        }
        #validator-panel .status-badge.exposed {
            background: rgba(248, 81, 73, 0.2);
            color: #f85149;
        }
        #validator-panel .status-badge.hidden {
            background: rgba(86, 211, 100, 0.2);
            color: #56d364;
        }
        #validator-panel .status-badge.jailed {
            background: rgba(210, 153, 34, 0.2);
            color: #d29922;
        }
        #validator-panel .section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin: 16px 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <!-- Export Loading Overlay -->
    <div id="export-overlay">
        <div id="export-dialog">
            <div class="export-spinner"></div>
            <div style="color: var(--text-primary); font-weight: 500;">Generating PDF...</div>
            <div style="color: var(--text-secondary); font-size: 12px; margin-top: 8px;">This may take a moment</div>
        </div>
    </div>

    <!-- Settings Dialog -->
    <div id="settings-overlay" onclick="if(event.target===this) closeSettings()">
        <div id="settings-dialog">
            <h3>
                <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97s-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1s.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66z"/></svg>
                Display Settings
            </h3>

            <div class="settings-section">
                <div class="settings-section-title">Appearance</div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Theme</div>
                        <div class="setting-sublabel">Light or dark color scheme</div>
                    </div>
                    <div class="setting-control">
                        <select id="theme" onchange="updateSetting('theme')">
                            <option value="dark">Dark</option>
                            <option value="light">Light</option>
                        </select>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Link Opacity</div>
                        <div class="setting-sublabel">Visibility of connection lines</div>
                    </div>
                    <div class="setting-control">
                        <input type="range" id="linkOpacity" min="0" max="100" value="50" oninput="updateSetting('linkOpacity')">
                        <span class="setting-value" id="linkOpacityVal">50%</span>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Link Width</div>
                        <div class="setting-sublabel">Thickness of connection lines</div>
                    </div>
                    <div class="setting-control">
                        <input type="range" id="linkWidth" min="1" max="5" value="1" oninput="updateSetting('linkWidth')">
                        <span class="setting-value" id="linkWidthVal">1px</span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title">Nodes</div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Node Size</div>
                        <div class="setting-sublabel">Scale factor for node circles</div>
                    </div>
                    <div class="setting-control">
                        <input type="range" id="nodeScale" min="50" max="200" value="100" oninput="updateSetting('nodeScale')">
                        <span class="setting-value" id="nodeScaleVal">100%</span>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Weighted Nodes</div>
                        <div class="setting-sublabel">Size by connection count</div>
                    </div>
                    <div class="setting-control">
                        <select id="weightedNodes" onchange="updateSetting('weightedNodes')">
                            <option value="true">On</option>
                            <option value="false" selected>Off</option>
                        </select>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Show Labels</div>
                        <div class="setting-sublabel">Display node names</div>
                    </div>
                    <div class="setting-control">
                        <select id="showLabels" onchange="updateSetting('showLabels')">
                            <option value="all">All</option>
                            <option value="rpc">RPC Only</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title">Layout</div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Layout Mode</div>
                        <div class="setting-sublabel">How nodes are arranged</div>
                    </div>
                    <div class="setting-control">
                        <select id="layoutMode" onchange="updateSetting('layoutMode')">
                            <option value="force">Force-Directed</option>
                            <option value="radial">Radial</option>
                            <option value="cluster">By Organization</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title">Discovery</div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Concurrent Connections</div>
                        <div class="setting-sublabel">Parallel request limit</div>
                    </div>
                    <div class="setting-control">
                        <input type="range" id="concurrentConns" min="1" max="20" value="5" oninput="updateSetting('concurrentConns')">
                        <span class="setting-value" id="concurrentConnsVal">5</span>
                    </div>
                </div>
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Auto Refresh</div>
                        <div class="setting-sublabel">Periodic re-discovery</div>
                    </div>
                    <div class="setting-control">
                        <select id="autoRefresh" onchange="updateSetting('autoRefresh')">
                            <option value="0">Off</option>
                            <option value="60">1 minute</option>
                            <option value="300">5 minutes</option>
                            <option value="600">10 minutes</option>
                            <option value="1800">30 minutes</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="btn-row">
                <button onclick="closeSettings()" class="btn-secondary">Cancel</button>
                <button onclick="applySettings()">Apply Changes</button>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="sidebar">
            <div class="header">
                <div class="header-icon">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                </div>
                <div>
                    <h1>Unofficial DCL Network Probe</h1>
                    <div class="header-subtitle">Distributed Compliance Ledger</div>
                </div>
            </div>
            <div class="section">
                <h2>Seed Nodes</h2>
                <textarea id="seedNodes" class="seed-input" rows="3">https://on.dcl.csa-iot.org:26657
http://13.52.115.12:26657
http://54.183.6.67:26657</textarea>
                <div class="button-group">
                    <button id="startBtn" onclick="startDiscovery()">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                        Start Discovery
                    </button>
                    <input type="file" id="loadJson" accept=".json" onchange="loadJsonFile(event)" style="display:none">
                    <button onclick="document.getElementById('loadJson').click()" class="btn-secondary">Load JSON</button>
                    <button id="continueBtn" onclick="continueDiscovery()" class="btn-primary-alt" style="display: none;">Continue Discovery</button>
                    <button id="probeValidatorsBtn" onclick="probeValidators()" class="btn-secondary" style="margin-top: 8px;">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg>
                        Probe Validators
                    </button>
                </div>
                <div class="helper-text">
                    <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                    Uses Vercel serverless proxy for HTTP endpoints
                </div>
            </div>
            <div class="section">
                <h2>Statistics</h2>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="nodeCount">0</div>
                        <div class="stat-label">Nodes</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="edgeCount">0</div>
                        <div class="stat-label">Connections</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="rpcCount">0</div>
                        <div class="stat-label">RPC Accessible</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="orgCount">0</div>
                        <div class="stat-label">Organizations</div>
                    </div>
                </div>
            </div>
            <div class="section" style="flex-shrink: 0;">
                <h2>Discovery Log</h2>
            </div>
            <div id="log"></div>
        </div>
        <div id="graph">
            <svg></svg>
            <div id="graph-legend">
                <div class="legend-item" data-type="validator" onclick="toggleTypeFilter('validator')">
                    <div class="legend-dot" style="background: linear-gradient(135deg, #f97583, #ff7b72)"></div>
                    <span>Validator</span>
                    <span class="legend-count" id="count-validator">0</span>
                </div>
                <div class="legend-item" data-type="sentry" onclick="toggleTypeFilter('sentry')">
                    <div class="legend-dot" style="background: linear-gradient(135deg, #56d364, #3fb950)"></div>
                    <span>Sentry</span>
                    <span class="legend-count" id="count-sentry">0</span>
                </div>
                <div class="legend-item" data-type="observer" onclick="toggleTypeFilter('observer')">
                    <div class="legend-dot" style="background: linear-gradient(135deg, #58a6ff, #388bfd)"></div>
                    <span>Observer</span>
                    <span class="legend-count" id="count-observer">0</span>
                </div>
                <div class="legend-item" data-type="seed" onclick="toggleTypeFilter('seed')">
                    <div class="legend-dot" style="background: linear-gradient(135deg, #d29922, #e3b341)"></div>
                    <span>Seed</span>
                    <span class="legend-count" id="count-seed">0</span>
                </div>
                <div class="legend-item" data-type="unknown" onclick="toggleTypeFilter('unknown')">
                    <div class="legend-dot" style="background: linear-gradient(135deg, #8b949e, #6e7681)"></div>
                    <span>Unknown</span>
                    <span class="legend-count" id="count-unknown">0</span>
                </div>
            </div>
            <div id="node-info"></div>
            <div id="validator-panel">
                <h3>
                    <span>On-Chain Validators</span>
                    <button class="close-btn" onclick="closeValidatorPanel()">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                    </button>
                </h3>
                <div class="summary">
                    <div class="summary-item">
                        <div class="summary-value" id="total-validators">-</div>
                        <div class="summary-label">Total Validators</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value danger" id="exposed-validators">-</div>
                        <div class="summary-label">P2P Exposed</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value success" id="hidden-validators">-</div>
                        <div class="summary-label">Properly Hidden</div>
                    </div>
                </div>
                <div class="section-title">Validator Details</div>
                <div class="validator-list" id="validator-list">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
            <div id="watermark">Unofficial DCL Network Probe</div>
            <div id="controls">
                <button onclick="zoomIn()">
                    <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    Zoom In
                </button>
                <button onclick="zoomOut()">
                    <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                    Zoom Out
                </button>
                <button onclick="resetZoom()">
                    <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                    Reset
                </button>
                <button onclick="exportData()">
                    <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Export JSON
                </button>
                <button onclick="exportPDF()">
                    <svg viewBox="0 0 24 24"><path d="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z"/></svg>
                    Export PDF
                </button>
                <button onclick="openSettings()">
                    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                    Settings
                </button>
            </div>
        </div>
    </div>

    <script>
        const TIMEOUT = 10000;
        const CORS_PROXY = "/api/proxy?apiurl=";

        function proxyUrl(url) {
            if (url.startsWith("https://on.dcl.csa-iot.org")) return url;
            return CORS_PROXY + encodeURIComponent(url);
        }

        const typeColors = {
            validator: "#f97583",
            sentry: "#56d364",
            observer: "#58a6ff",
            seed: "#d29922",
            unknown: "#8b949e"
        };

        const typeBadgeColors = {
            validator: { bg: "rgba(249, 117, 131, 0.2)", color: "#f97583" },
            sentry: { bg: "rgba(86, 211, 100, 0.2)", color: "#56d364" },
            observer: { bg: "rgba(88, 166, 255, 0.2)", color: "#58a6ff" },
            seed: { bg: "rgba(210, 153, 34, 0.2)", color: "#d29922" },
            unknown: { bg: "rgba(139, 148, 158, 0.2)", color: "#8b949e" }
        };

        // State
        let nodes = {};
        let edges = [];
        let edgeSet = new Set();
        let visitedRpcs = new Set();
        let discoveryQueue = [];
        let isDiscovering = false;

        // Type filter state - all types visible by default
        let activeTypes = new Set(['validator', 'sentry', 'observer', 'seed', 'unknown']);

        let simulation, svg, g, linkGroup, nodeGroup, zoom;

        // Utility functions
        function isPrivateIP(ip) {
            return ip.startsWith("10.") ||
                   ip.startsWith("172.16.") || ip.startsWith("172.17.") ||
                   ip.startsWith("172.18.") || ip.startsWith("172.19.") ||
                   ip.startsWith("172.2") || ip.startsWith("172.30.") || ip.startsWith("172.31.") ||
                   ip.startsWith("192.168.") ||
                   ip.startsWith("127.");
        }

        function getNodeType(moniker) {
            const m = moniker.toLowerCase();
            if (m.includes("-vn-") || m.endsWith("-vn")) return "validator";
            if (m.includes("-sn-") || m.includes("sentry")) return "sentry";
            if (m.includes("-on-") || m.includes("observer")) return "observer";
            if (m.includes("seed")) return "seed";
            return "unknown";
        }

        function getOrg(moniker) {
            if (moniker.includes("-")) return moniker.split("-")[0];
            return moniker;
        }

        function log(msg, type = "info") {
            const logEl = document.getElementById("log");
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement("div");
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${time}] ${msg}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
            while (logEl.children.length > 100) {
                logEl.removeChild(logEl.firstChild);
            }
        }

        // Network requests
        async function fetchWithTimeout(url, timeout = TIMEOUT) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                return response;
            } catch (e) {
                clearTimeout(timeoutId);
                throw e;
            }
        }

        async function queryNetInfo(rpcUrl) {
            try {
                const resp = await fetchWithTimeout(proxyUrl(`${rpcUrl}/net_info`));
                const data = await resp.json();
                return data.result?.peers || [];
            } catch (e) {
                return [];
            }
        }

        async function queryStatus(rpcUrl) {
            try {
                const resp = await fetchWithTimeout(proxyUrl(`${rpcUrl}/status`));
                const data = await resp.json();
                const nodeInfo = data.result?.node_info || {};
                const syncInfo = data.result?.sync_info || {};
                return {
                    id: nodeInfo.id,
                    moniker: nodeInfo.moniker,
                    version: nodeInfo.version,
                    height: syncInfo.latest_block_height
                };
            } catch (e) {
                return null;
            }
        }

        async function queryAbciInfo(rpcUrl) {
            try {
                const resp = await fetchWithTimeout(proxyUrl(`${rpcUrl}/abci_info`));
                const data = await resp.json();
                return data.result?.response?.version || null;
            } catch (e) {
                return null;
            }
        }

        // Query on-chain validators via Tendermint RPC
        async function queryOnChainValidators(rpcUrl) {
            try {
                // Get current validators from consensus
                const resp = await fetchWithTimeout(proxyUrl(`${rpcUrl}/validators?per_page=100`));
                const data = await resp.json();
                return data.result?.validators || [];
            } catch (e) {
                log(`Failed to query validators: ${e.message}`, 'error');
                return [];
            }
        }

        // Query DCL validator module via LCD REST API (port 1317)
        async function queryDclValidators(rpcUrl) {
            try {
                // Try LCD endpoint first (replace RPC port 26657 with LCD port 1317)
                const lcdUrl = rpcUrl.replace(':26657', ':1317').replace(':443', ':1317');
                const resp = await fetchWithTimeout(proxyUrl(`${lcdUrl}/dcl/validator/nodes`), 5000);
                const data = await resp.json();
                return data.validator || [];
            } catch (e) {
                // LCD not available, return empty
                return [];
            }
        }

        // Probe validators - compare on-chain validators with P2P discovered nodes
        async function probeValidators() {
            const btn = document.getElementById('probeValidatorsBtn');
            btn.disabled = true;
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg> Probing...';

            log('Probing on-chain validators...');

            // Get RPC URL from seed nodes
            const seedText = document.getElementById("seedNodes").value;
            const seedUrls = seedText.split("\n").map(s => s.trim()).filter(s => s);

            if (seedUrls.length === 0) {
                log('No seed nodes configured', 'error');
                btn.disabled = false;
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg> Probe Validators';
                return;
            }

            // Try to get DCL validators with monikers from LCD endpoint
            let dclValidators = [];
            for (const rpcUrl of seedUrls) {
                dclValidators = await queryDclValidators(rpcUrl);
                if (dclValidators.length > 0) {
                    log(`Found ${dclValidators.length} DCL validators with monikers`, 'success');
                    break;
                }
            }

            // Also get consensus validators from Tendermint RPC
            let onChainValidators = [];
            for (const rpcUrl of seedUrls) {
                onChainValidators = await queryOnChainValidators(rpcUrl);
                if (onChainValidators.length > 0) {
                    log(`Found ${onChainValidators.length} consensus validators from ${rpcUrl}`, 'success');
                    break;
                }
            }

            if (onChainValidators.length === 0 && dclValidators.length === 0) {
                log('Could not fetch validators from any seed node', 'error');
                btn.disabled = false;
                btn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg> Probe Validators';
                return;
            }

            // Get P2P discovered validators (nodes with type "validator")
            const p2pValidators = Object.values(nodes).filter(n => n.type === 'validator');

            // Build a map of P2P validators by moniker (lowercase) for matching
            const p2pByMoniker = {};
            p2pValidators.forEach(v => {
                p2pByMoniker[v.moniker.toLowerCase()] = v;
            });

            // Use DCL validators if available (they have monikers), otherwise use consensus validators
            const totalOnChain = dclValidators.length > 0 ? dclValidators.length : onChainValidators.length;

            // Match DCL validators with P2P discovered nodes
            const validatorAnalysis = dclValidators.length > 0
                ? dclValidators.map(v => {
                    const moniker = v.description?.moniker || 'Unknown';
                    const owner = v.owner || '';
                    const jailed = v.jailed || false;
                    const power = v.power || 0;

                    // Check if this validator was discovered via P2P
                    const p2pMatch = p2pByMoniker[moniker.toLowerCase()];

                    return {
                        moniker,
                        owner,
                        jailed,
                        power,
                        p2pMatch,
                        isExposed: !!p2pMatch
                    };
                })
                : onChainValidators.map(v => ({
                    moniker: null,
                    address: v.address,
                    votingPower: v.voting_power,
                    p2pMatch: null,
                    isExposed: false
                }));

            // Count exposed vs hidden
            const exposedCount = validatorAnalysis.filter(v => v.isExposed).length;
            const hiddenCount = totalOnChain - exposedCount;

            // Update panel summary
            document.getElementById('total-validators').textContent = totalOnChain;
            document.getElementById('exposed-validators').textContent = exposedCount;
            document.getElementById('hidden-validators').textContent = hiddenCount;

            // Build the validator list HTML
            let listHtml = '';

            if (dclValidators.length > 0) {
                // Show DCL validators with their exposure status
                listHtml = `
                    <div class="section-title">Registered Validators (${dclValidators.length})</div>
                    ${validatorAnalysis.map(v => {
                        let statusClass, statusText;
                        if (v.jailed) {
                            statusClass = 'jailed';
                            statusText = 'Jailed';
                        } else if (v.isExposed) {
                            statusClass = 'exposed';
                            statusText = 'P2P Exposed';
                        } else {
                            statusClass = 'hidden';
                            statusText = 'Hidden';
                        }

                        const p2pInfo = v.p2pMatch
                            ? `<div class="validator-details">${v.p2pMatch.ip}:${v.p2pMatch.port} | RPC: ${v.p2pMatch.rpc_accessible ? 'Open' : 'Closed'}</div>`
                            : `<div class="validator-details">Not discovered via P2P gossip</div>`;

                        return `
                            <div class="validator-item">
                                <div class="validator-info">
                                    <div class="validator-name">${v.moniker}</div>
                                    ${p2pInfo}
                                    <div class="validator-details" style="font-size: 10px; color: var(--text-muted);">
                                        Owner: ${v.owner.slice(0, 20)}... | Power: ${v.power}
                                    </div>
                                </div>
                                <div class="validator-status">
                                    <span class="status-badge ${statusClass}">${statusText}</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            } else {
                // Fallback: show P2P discovered validators
                listHtml = `
                    <div class="section-title">P2P Discovered Validators (${p2pValidators.length})</div>
                    ${p2pValidators.length > 0
                        ? p2pValidators.map(v => {
                            const statusClass = v.rpc_accessible ? 'exposed' : 'hidden';
                            const statusText = v.rpc_accessible ? 'RPC Exposed' : 'RPC Hidden';
                            return `
                                <div class="validator-item">
                                    <div class="validator-info">
                                        <div class="validator-name">${v.moniker}</div>
                                        <div class="validator-details">
                                            ${v.ip}:${v.port} | ${v.id.slice(0, 16)}...
                                        </div>
                                    </div>
                                    <div class="validator-status">
                                        <span class="status-badge ${statusClass}">${statusText}</span>
                                    </div>
                                </div>
                            `;
                        }).join('')
                        : `<div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                            <p>No validators discovered via P2P gossip.</p>
                            <p style="font-size: 11px; margin-top: 8px;">Run network discovery first, or validators are properly hidden.</p>
                           </div>`
                    }
                    <div class="section-title" style="margin-top: 20px;">Consensus Validators (${onChainValidators.length})</div>
                    <div style="font-size: 11px; color: var(--text-muted); padding: 8px 0;">
                        LCD endpoint not available. Showing consensus addresses only (no monikers).
                    </div>
                    ${onChainValidators.map(v => `
                        <div class="validator-item">
                            <div class="validator-info">
                                <div class="validator-name" style="font-family: monospace; font-size: 11px;">${v.address}</div>
                                <div class="validator-details">
                                    Voting Power: ${v.voting_power}
                                </div>
                            </div>
                        </div>
                    `).join('')}
                `;
            }

            document.getElementById('validator-list').innerHTML = listHtml;

            // Show panel
            document.getElementById('validator-panel').style.display = 'block';

            log(`Validator probe complete: ${exposedCount} exposed via P2P, ${hiddenCount} properly hidden`,
                exposedCount > 0 ? 'error' : 'success');

            btn.disabled = false;
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg> Probe Validators';
        }

        function closeValidatorPanel() {
            document.getElementById('validator-panel').style.display = 'none';
        }

        // Node management
        function addNode(id, ip, moniker, version, rpcAccessible = false, dclVersion = null, height = null) {
            if (!nodes[id]) {
                nodes[id] = {
                    id, ip, port: 26656,
                    moniker: moniker || "unknown",
                    tendermint_version: version || "unknown",
                    rpc_accessible: rpcAccessible,
                    dcl_version: dclVersion,
                    height,
                    type: getNodeType(moniker || ""),
                    org: getOrg(moniker || "unknown"),
                    rpc_url: `http://${ip}:26657`
                };
            } else {
                if (rpcAccessible) nodes[id].rpc_accessible = true;
                if (dclVersion) nodes[id].dcl_version = dclVersion;
                if (height) nodes[id].height = height;
            }
        }

        function addEdge(sourceId, targetId) {
            const key = [sourceId, targetId].sort().join("-");
            if (!edgeSet.has(key)) {
                edgeSet.add(key);
                edges.push({ source: sourceId, target: targetId });
            }
        }

        // Discovery
        async function discoverFromNode(sourceId, rpcUrl) {
            if (visitedRpcs.has(rpcUrl)) return [];
            visitedRpcs.add(rpcUrl);
            const peers = await queryNetInfo(rpcUrl);
            const newPeers = [];
            for (const peer of peers) {
                const nodeInfo = peer.node_info || {};
                const peerId = nodeInfo.id;
                const remoteIp = peer.remote_ip;
                if (!peerId || !remoteIp) continue;
                if (isPrivateIP(remoteIp)) continue;
                const isNew = !nodes[peerId];
                addNode(peerId, remoteIp, nodeInfo.moniker, nodeInfo.version);
                if (sourceId) addEdge(sourceId, peerId);
                if (isNew) newPeers.push(peerId);
            }
            return newPeers;
        }

        async function crawlNode(peerId) {
            const node = nodes[peerId];
            if (!node) return;
            const rpcUrl = node.rpc_url;
            log(`Crawling ${node.moniker} (${node.ip})`);
            const status = await queryStatus(rpcUrl);
            if (status) {
                const dclVersion = await queryAbciInfo(rpcUrl);
                addNode(peerId, node.ip, node.moniker, node.tendermint_version, true, dclVersion, status.height);
                log(`  RPC accessible, DCL v${dclVersion || "?"}`, "success");
            }
            const newPeers = await discoverFromNode(peerId, rpcUrl);
            if (newPeers.length > 0) {
                log(`  Found ${newPeers.length} new peers`);
                discoveryQueue.push(...newPeers);
            }
            node._discovered = true;
            updateGraph();
            updateStats();
        }

        async function startDiscovery() {
            if (isDiscovering) return;
            nodes = {};
            edges = [];
            edgeSet.clear();
            visitedRpcs.clear();
            discoveryQueue = [];
            isDiscovering = true;
            document.getElementById("startBtn").disabled = true;
            document.getElementById("startBtn").innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor" style="animation: spin 1s linear infinite;"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg> Discovering...';
            document.getElementById("log").innerHTML = "";
            log("Starting peer discovery...");
            const seedText = document.getElementById("seedNodes").value;
            const seedUrls = seedText.split("\n").map(s => s.trim()).filter(s => s);
            for (const rpcUrl of seedUrls) {
                log(`Querying seed: ${rpcUrl}`);
                const status = await queryStatus(rpcUrl);
                if (status && status.id) {
                    const dclVersion = await queryAbciInfo(rpcUrl);
                    const ip = rpcUrl.replace(/https?:\/\//, "").split(":")[0];
                    addNode(status.id, ip, status.moniker, status.version, true, dclVersion, status.height);
                    const newPeers = await discoverFromNode(status.id, rpcUrl);
                    log(`  Found ${newPeers.length} peers`, "success");
                    discoveryQueue.push(...newPeers);
                    nodes[status.id]._discovered = true;
                } else {
                    log(`  Failed to connect`, "error");
                }
                updateGraph();
                updateStats();
            }
            log(`Initial discovery: ${Object.keys(nodes).length} nodes`);
            while (discoveryQueue.length > 0) {
                const batch = discoveryQueue.splice(0, settings.concurrentConns);
                await Promise.all(batch.map(peerId => {
                    if (!nodes[peerId]?._discovered) return crawlNode(peerId);
                }));
            }
            isDiscovering = false;
            document.getElementById("startBtn").disabled = false;
            document.getElementById("startBtn").innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg> Restart Discovery';
            log(`Discovery complete: ${Object.keys(nodes).length} nodes, ${edges.length} connections`, "success");
        }

        // Graph visualization
        function initGraph() {
            svg = d3.select("#graph > svg");
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", (event) => g.attr("transform", event.transform));
            svg.call(zoom)
               .on("click", (event) => {
                   if (event.target.tagName === "svg") clearSelection();
               });
            g = svg.append("g");
            linkGroup = g.append("g").attr("class", "links");
            nodeGroup = g.append("g").attr("class", "nodes");
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(40));
            simulation.on("tick", () => {
                linkGroup.selectAll("line")
                    .attr("x1", d => d.source.x || 0)
                    .attr("y1", d => d.source.y || 0)
                    .attr("x2", d => d.target.x || 0)
                    .attr("y2", d => d.target.y || 0)
                    .style("visibility", d =>
                        (d.source.x !== undefined && d.target.x !== undefined) ? "visible" : "hidden"
                    );
                nodeGroup.selectAll("g.node")
                    .attr("transform", d => `translate(${d.x || 0},${d.y || 0})`);
            });
        }

        function updateGraph() {
            const nodeArray = Object.values(nodes);
            const validEdges = edges.filter(e => {
                const srcId = typeof e.source === 'object' ? e.source.id : e.source;
                const tgtId = typeof e.target === 'object' ? e.target.id : e.target;
                return nodes[srcId] && nodes[tgtId];
            });

            // Calculate node degrees
            const nodeDegrees = {};
            edges.forEach(e => {
                const srcId = typeof e.source === 'object' ? e.source.id : e.source;
                const tgtId = typeof e.target === 'object' ? e.target.id : e.target;
                nodeDegrees[srcId] = (nodeDegrees[srcId] || 0) + 1;
                nodeDegrees[tgtId] = (nodeDegrees[tgtId] || 0) + 1;
            });
            const maxDegree = Math.max(...Object.values(nodeDegrees), 1);

            function getNodeRadius(d) {
                const baseSize = d.rpc_accessible ? 14 : 10;
                if (!settings.weightedNodes) return baseSize;
                const degree = nodeDegrees[d.id] || 0;
                const scale = 1 + (degree / maxDegree) * 1.5;
                return baseSize * scale;
            }

            // Update links
            const link = linkGroup.selectAll("line").data(validEdges, d => {
                const srcId = typeof d.source === 'object' ? d.source.id : d.source;
                const tgtId = typeof d.target === 'object' ? d.target.id : d.target;
                return `${srcId}-${tgtId}`;
            });
            link.exit().remove();
            link.enter().append("line").attr("class", "link");

            // Update nodes
            const node = nodeGroup.selectAll("g.node").data(nodeArray, d => d.id);
            node.exit().remove();

            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("click", showNodeInfo)
                .on("mouseover", highlightConnections)
                .on("mouseout", clearHighlight);

            nodeEnter.append("circle")
                .attr("r", d => getNodeRadius(d) * (settings.nodeScale / 100))
                .attr("fill", d => typeColors[d.type] || typeColors.unknown);

            nodeEnter.append("text")
                .attr("dy", d => getNodeRadius(d) * (settings.nodeScale / 100) + 14)
                .attr("text-anchor", "middle")
                .text(d => d.moniker.length > 18 ? d.moniker.slice(0, 18) + "..." : d.moniker);

            // Update existing
            nodeGroup.selectAll("g.node circle")
                .attr("r", d => getNodeRadius(d) * (settings.nodeScale / 100))
                .attr("fill", d => typeColors[d.type] || typeColors.unknown);

            nodeGroup.selectAll("g.node text")
                .attr("dy", d => getNodeRadius(d) * (settings.nodeScale / 100) + 14);

            // Apply layout
            applyLayout();

            simulation.nodes(nodeArray);
            simulation.force("link").links(validEdges);

            // Use lower alpha for smoother updates during discovery
            // Only use higher alpha when explicitly needed (layout change)
            if (!isDiscovering) {
                simulation.alpha(0.3).restart();
            } else {
                // Gentler simulation during discovery to prevent flashing
                simulation.alpha(0.1).alphaDecay(0.02).restart();
            }

            // Apply type filter
            applyTypeFilter();
        }

        function applyLayout() {
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;
            const nodeArray = Object.values(nodes);

            if (settings.layoutMode === 'radial') {
                // Radial layout - validators in center, others in rings
                const types = ['validator', 'sentry', 'observer', 'seed', 'unknown'];
                const ringRadius = Math.min(width, height) / 4;
                types.forEach((type, ringIndex) => {
                    const typeNodes = nodeArray.filter(n => n.type === type);
                    typeNodes.forEach((n, i) => {
                        const angle = (2 * Math.PI * i) / typeNodes.length;
                        const r = ringRadius * (ringIndex + 1) / types.length;
                        n.x = width / 2 + r * Math.cos(angle);
                        n.y = height / 2 + r * Math.sin(angle);
                    });
                });
                simulation.force("center", null);
            } else if (settings.layoutMode === 'cluster') {
                // Group by organization
                const orgs = [...new Set(nodeArray.map(n => n.org))];
                const cols = Math.ceil(Math.sqrt(orgs.length));
                const cellW = width / cols;
                const cellH = height / Math.ceil(orgs.length / cols);
                orgs.forEach((org, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const orgNodes = nodeArray.filter(n => n.org === org);
                    orgNodes.forEach((n, j) => {
                        const angle = (2 * Math.PI * j) / orgNodes.length;
                        const r = Math.min(cellW, cellH) / 4;
                        n.x = cellW * col + cellW / 2 + r * Math.cos(angle);
                        n.y = cellH * row + cellH / 2 + r * Math.sin(angle);
                    });
                });
                simulation.force("center", null);
            } else {
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }
        }

        function updateStats() {
            const nodeArray = Object.values(nodes);
            const orgs = new Set(nodeArray.map(n => n.org));
            document.getElementById("nodeCount").textContent = nodeArray.length;
            document.getElementById("edgeCount").textContent = edges.length;
            document.getElementById("rpcCount").textContent = nodeArray.filter(n => n.rpc_accessible).length;
            document.getElementById("orgCount").textContent = orgs.size;

            // Update legend counts
            const typeCounts = { validator: 0, sentry: 0, observer: 0, seed: 0, unknown: 0 };
            nodeArray.forEach(n => {
                typeCounts[n.type] = (typeCounts[n.type] || 0) + 1;
            });
            Object.entries(typeCounts).forEach(([type, count]) => {
                const el = document.getElementById(`count-${type}`);
                if (el) el.textContent = count;
            });
        }

        function toggleTypeFilter(type) {
            if (activeTypes.has(type)) {
                // Don't allow deselecting all types
                if (activeTypes.size > 1) {
                    activeTypes.delete(type);
                }
            } else {
                activeTypes.add(type);
            }
            updateLegendUI();
            applyTypeFilter();
        }

        function updateLegendUI() {
            document.querySelectorAll('#graph-legend .legend-item').forEach(item => {
                const type = item.dataset.type;
                if (activeTypes.has(type)) {
                    item.classList.remove('inactive');
                } else {
                    item.classList.add('inactive');
                }
            });
        }

        function applyTypeFilter() {
            // Filter nodes
            nodeGroup.selectAll("g.node")
                .style("opacity", d => activeTypes.has(d.type) ? 1 : 0.15)
                .style("pointer-events", d => activeTypes.has(d.type) ? "auto" : "none");

            // Filter links - show at reduced opacity if either end is filtered
            linkGroup.selectAll("line")
                .style("opacity", d => {
                    const srcType = typeof d.source === 'object' ? d.source.type : nodes[d.source]?.type;
                    const tgtType = typeof d.target === 'object' ? d.target.type : nodes[d.target]?.type;
                    if (activeTypes.has(srcType) && activeTypes.has(tgtType)) {
                        return settings.linkOpacity / 100;
                    }
                    return 0.05;
                });
        }

        function showNodeInfo(event, d) {
            let connectionCount = 0;
            edges.forEach(e => {
                const srcId = typeof e.source === 'object' ? e.source.id : e.source;
                const tgtId = typeof e.target === 'object' ? e.target.id : e.target;
                if (srcId === d.id || tgtId === d.id) connectionCount++;
            });
            highlightConnections(event, d, true);
            const badge = typeBadgeColors[d.type] || typeBadgeColors.unknown;
            const info = document.getElementById("node-info");
            info.style.display = "block";
            info.innerHTML = `
                <h3>
                    ${d.moniker}
                    <span class="type-badge" style="background: ${badge.bg}; color: ${badge.color}">${d.type}</span>
                </h3>
                <div class="row"><span class="label">Organization</span><span class="value">${d.org}</span></div>
                <div class="row"><span class="label">Connections</span><span class="value">${connectionCount}</span></div>
                <div class="row"><span class="label">IP Address</span><span class="value">${d.ip}</span></div>
                <div class="row"><span class="label">Node ID</span><span class="value" style="font-size:10px">${d.id}</span></div>
                <div class="row"><span class="label">RPC Accessible</span><span class="value">${d.rpc_accessible ? "Yes" : "No"}</span></div>
                <div class="row"><span class="label">DCL Version</span><span class="value">${d.dcl_version || "N/A"}</span></div>
                <div class="row"><span class="label">Block Height</span><span class="value">${d.height || "N/A"}</span></div>
                <div class="row"><span class="label">Tendermint</span><span class="value">${d.tendermint_version}</span></div>
            `;
        }

        let selectedNodeId = null;

        function highlightConnections(event, d, persistent = false) {
            if (persistent) selectedNodeId = d.id;
            const connectedIds = new Set([d.id]);
            linkGroup.selectAll("line").classed("highlighted", l => {
                const srcId = typeof l.source === "object" ? l.source.id : l.source;
                const tgtId = typeof l.target === "object" ? l.target.id : l.target;
                if (srcId === d.id || tgtId === d.id) {
                    connectedIds.add(srcId);
                    connectedIds.add(tgtId);
                    return true;
                }
                return false;
            });
            nodeGroup.selectAll("g.node").classed("highlighted", n => connectedIds.has(n.id));
        }

        function clearHighlight() {
            if (selectedNodeId && nodes[selectedNodeId]) {
                highlightConnections(null, nodes[selectedNodeId], false);
            } else {
                linkGroup.selectAll("line").classed("highlighted", false);
                nodeGroup.selectAll("g.node").classed("highlighted", false);
            }
        }

        function clearSelection() {
            selectedNodeId = null;
            document.getElementById("node-info").style.display = "none";
            linkGroup.selectAll("line").classed("highlighted", false);
            nodeGroup.selectAll("g.node").classed("highlighted", false);
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function zoomIn() { svg.transition().call(zoom.scaleBy, 1.3); }
        function zoomOut() { svg.transition().call(zoom.scaleBy, 0.7); }
        function resetZoom() { svg.transition().call(zoom.transform, d3.zoomIdentity); }

        function exportData() {
            const normalizedEdges = edges.map(e => ({
                source: typeof e.source === 'object' ? e.source.id : e.source,
                target: typeof e.target === 'object' ? e.target.id : e.target
            }));
            const data = { nodes, edges: normalizedEdges, exported_at: new Date().toISOString() };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `dcl-network-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function exportPDF() {
            document.getElementById("export-overlay").style.display = "flex";
            document.getElementById("watermark").style.display = "block";
            document.getElementById("controls").style.display = "none";
            document.getElementById("node-info").style.display = "none";
            document.getElementById("graph-legend").style.display = "none";

            await new Promise(r => setTimeout(r, 100));

            try {
                const graphEl = document.getElementById("graph");
                const canvas = await html2canvas(graphEl, {
                    backgroundColor: getComputedStyle(document.body).getPropertyValue('--graph-bg'),
                    scale: 2  // Higher quality
                });

                const { jsPDF } = window.jspdf;
                // Use PNG for better quality
                const imgData = canvas.toDataURL('image/png');

                // Use standard page size
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4',
                    compress: true
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();

                // Calculate content dimensions
                const margin = 15;
                const footerHeight = 12;
                const legendHeight = 20;
                const contentHeight = pageHeight - (margin * 2) - footerHeight;

                const imgRatio = canvas.width / canvas.height;

                // Calculate image size to fit in content area (leaving room for legend below)
                const availableHeight = contentHeight - legendHeight;
                const availableWidth = pageWidth - (margin * 2);

                let imgWidth = availableWidth;
                let imgHeight = imgWidth / imgRatio;

                if (imgHeight > availableHeight) {
                    imgHeight = availableHeight;
                    imgWidth = imgHeight * imgRatio;
                }

                // Center everything vertically and horizontally
                const totalContentHeight = imgHeight + legendHeight;
                const contentStartY = margin + (contentHeight - totalContentHeight) / 2;

                const imgX = (pageWidth - imgWidth) / 2;
                const imgY = contentStartY;

                pdf.addImage(imgData, 'PNG', imgX, imgY, imgWidth, imgHeight);

                // Legend colors
                const legendColors = {
                    Validator: [249, 117, 131],
                    Sentry: [86, 211, 100],
                    Observer: [88, 166, 255],
                    Seed: [210, 153, 34],
                    Unknown: [139, 148, 158]
                };

                // Count by type (capitalize)
                const typeCounts = {};
                Object.values(nodes).forEach(n => {
                    const type = n.type.charAt(0).toUpperCase() + n.type.slice(1);
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });

                // Calculate legend width to center it
                pdf.setFontSize(9);
                let totalLegendWidth = 0;
                const legendItems = Object.entries(typeCounts);
                legendItems.forEach(([type, count]) => {
                    totalLegendWidth += 8 + pdf.getTextWidth(`${type}: ${count}`) + 12;
                });

                // Draw legend centered below graph
                const legendY = imgY + imgHeight + 12;
                let legendX = (pageWidth - totalLegendWidth) / 2;

                for (const [type, count] of legendItems) {
                    const color = legendColors[type] || legendColors.Unknown;
                    pdf.setFillColor(color[0], color[1], color[2]);
                    pdf.circle(legendX + 3, legendY, 3, 'F');
                    pdf.setTextColor(80, 80, 80);
                    const label = `${type}: ${count}`;
                    pdf.text(label, legendX + 8, legendY + 1);
                    legendX += 8 + pdf.getTextWidth(label) + 12;
                }

                // Footer with title, stats, and date
                const footerY = pageHeight - margin;
                pdf.setFontSize(8);
                pdf.setTextColor(140, 140, 140);
                pdf.text('Unofficial DCL Network Probe', margin, footerY);

                const statsText = `Nodes: ${Object.keys(nodes).length}  |  Connections: ${edges.length}  |  RPC Accessible: ${Object.values(nodes).filter(n => n.rpc_accessible).length}  |  Organizations: ${new Set(Object.values(nodes).map(n => n.org)).size}`;
                pdf.text(statsText, pageWidth / 2, footerY, { align: 'center' });

                pdf.text(new Date().toLocaleString(), pageWidth - margin, footerY, { align: 'right' });

                pdf.save(`dcl-network-${new Date().toISOString().slice(0,10)}.pdf`);
                log('PDF exported successfully', 'success');
            } catch (err) {
                log(`PDF export failed: ${err.message}`, 'error');
            }

            document.getElementById("export-overlay").style.display = "none";
            document.getElementById("watermark").style.display = "none";
            document.getElementById("controls").style.display = "flex";
            document.getElementById("graph-legend").style.display = "flex";
        }

        function loadJsonFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    nodes = data.nodes || {};
                    Object.values(nodes).forEach(n => { delete n._discovered; });
                    edges = (data.edges || []).map(e => ({
                        source: typeof e.source === 'object' ? e.source.id : e.source,
                        target: typeof e.target === 'object' ? e.target.id : e.target
                    }));
                    edgeSet.clear();
                    visitedRpcs.clear();
                    edges.forEach(e => {
                        const key = [e.source, e.target].sort().join("-");
                        edgeSet.add(key);
                    });
                    const rpcNodes = Object.values(nodes).filter(n => n.rpc_accessible);
                    log(`Loaded ${Object.keys(nodes).length} nodes, ${edges.length} edges from file`, "success");
                    log(`${rpcNodes.length} RPC-accessible nodes available for discovery`);
                    document.getElementById('continueBtn').style.display = rpcNodes.length > 0 ? 'block' : 'none';
                    updateGraph();
                    updateStats();
                } catch (err) {
                    log(`Error loading JSON: ${err.message}`, "error");
                }
            };
            reader.readAsText(file);
        }

        async function continueDiscovery() {
            if (isDiscovering) return;
            isDiscovering = true;
            document.getElementById("continueBtn").disabled = true;
            document.getElementById("continueBtn").textContent = "Discovering...";
            document.getElementById("startBtn").disabled = true;
            log("Continuing discovery from loaded nodes...");
            const rpcNodes = Object.values(nodes).filter(n => n.rpc_accessible && !n._discovered);
            discoveryQueue = rpcNodes.map(n => n.id);
            log(`Queued ${discoveryQueue.length} RPC-accessible nodes for crawling`);
            const nonRpcNodes = Object.values(nodes).filter(n => !n.rpc_accessible && !n._discovered);
            discoveryQueue.push(...nonRpcNodes.map(n => n.id));
            log(`Total ${discoveryQueue.length} nodes queued (including ${nonRpcNodes.length} previously inaccessible)`);
            while (discoveryQueue.length > 0) {
                const batch = discoveryQueue.splice(0, settings.concurrentConns);
                await Promise.all(batch.map(peerId => {
                    if (!nodes[peerId]?._discovered) return crawlNode(peerId);
                }));
            }
            isDiscovering = false;
            document.getElementById("continueBtn").disabled = false;
            document.getElementById("continueBtn").textContent = "Continue Discovery";
            document.getElementById("startBtn").disabled = false;
            log(`Discovery complete: ${Object.keys(nodes).length} nodes, ${edges.length} connections`, "success");
        }

        // Settings
        const defaultSettings = {
            theme: 'dark',
            linkOpacity: 50,
            linkWidth: 1,
            nodeScale: 100,
            weightedNodes: false,
            showLabels: 'all',
            layoutMode: 'force',
            concurrentConns: 5,
            autoRefresh: 0
        };

        // Load settings from localStorage or use defaults
        let settings = { ...defaultSettings };
        try {
            const saved = localStorage.getItem('dcl-explorer-settings');
            if (saved) {
                settings = { ...defaultSettings, ...JSON.parse(saved) };
            }
        } catch (e) {
            console.warn('Failed to load settings:', e);
        }

        function saveSettings() {
            try {
                localStorage.setItem('dcl-explorer-settings', JSON.stringify(settings));
            } catch (e) {
                console.warn('Failed to save settings:', e);
            }
        }

        let autoRefreshTimer = null;

        function openSettings() {
            document.getElementById('settings-overlay').style.display = 'flex';
            document.getElementById('theme').value = settings.theme;
            document.getElementById('linkOpacity').value = settings.linkOpacity;
            document.getElementById('linkOpacityVal').textContent = settings.linkOpacity + '%';
            document.getElementById('linkWidth').value = settings.linkWidth;
            document.getElementById('linkWidthVal').textContent = settings.linkWidth + 'px';
            document.getElementById('nodeScale').value = settings.nodeScale;
            document.getElementById('nodeScaleVal').textContent = settings.nodeScale + '%';
            document.getElementById('weightedNodes').value = settings.weightedNodes ? 'true' : 'false';
            document.getElementById('showLabels').value = settings.showLabels;
            document.getElementById('layoutMode').value = settings.layoutMode;
            document.getElementById('concurrentConns').value = settings.concurrentConns;
            document.getElementById('concurrentConnsVal').textContent = settings.concurrentConns;
            document.getElementById('autoRefresh').value = settings.autoRefresh;
        }

        function closeSettings() {
            document.getElementById('settings-overlay').style.display = 'none';
        }

        function updateSetting(key) {
            const el = document.getElementById(key);
            const val = el.value;
            if (key === 'linkOpacity') {
                document.getElementById('linkOpacityVal').textContent = val + '%';
            } else if (key === 'linkWidth') {
                document.getElementById('linkWidthVal').textContent = val + 'px';
            } else if (key === 'nodeScale') {
                document.getElementById('nodeScaleVal').textContent = val + '%';
            } else if (key === 'concurrentConns') {
                document.getElementById('concurrentConnsVal').textContent = val;
            }
        }

        function applySettings() {
            const prevLayoutMode = settings.layoutMode;

            settings.theme = document.getElementById('theme').value;
            settings.linkOpacity = parseInt(document.getElementById('linkOpacity').value);
            settings.linkWidth = parseInt(document.getElementById('linkWidth').value);
            settings.nodeScale = parseInt(document.getElementById('nodeScale').value);
            settings.weightedNodes = document.getElementById('weightedNodes').value === 'true';
            settings.showLabels = document.getElementById('showLabels').value;
            settings.layoutMode = document.getElementById('layoutMode').value;
            settings.concurrentConns = parseInt(document.getElementById('concurrentConns').value);
            settings.autoRefresh = parseInt(document.getElementById('autoRefresh').value);

            const layoutChanged = prevLayoutMode !== settings.layoutMode;

            // Apply theme
            document.body.setAttribute('data-theme', settings.theme);

            // Apply link styles
            linkGroup.selectAll("line")
                .style("stroke-opacity", settings.linkOpacity / 100)
                .style("stroke-width", settings.linkWidth + "px");

            // Re-render graph
            updateGraph();

            // Reset zoom/pan to center the graph only if layout mode changed
            if (layoutChanged) {
                svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
            }

            // Apply label visibility
            nodeGroup.selectAll("g.node text")
                .style("display", d => {
                    if (settings.showLabels === 'none') return 'none';
                    if (settings.showLabels === 'rpc' && !d.rpc_accessible) return 'none';
                    return 'block';
                });

            // Auto-refresh
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (settings.autoRefresh > 0) {
                autoRefreshTimer = setInterval(() => {
                    if (!isDiscovering) {
                        log('Auto-refresh triggered');
                        startDiscovery();
                    }
                }, settings.autoRefresh * 1000);
                log(`Auto-refresh set to ${settings.autoRefresh}s`);
            }

            // Save to localStorage
            saveSettings();

            closeSettings();
            log('Settings applied');
        }

        // Apply saved settings on page load
        function applyInitialSettings() {
            // Apply theme
            document.body.setAttribute('data-theme', settings.theme);
        }

        // Initialize
        applyInitialSettings();
        initGraph();

        window.addEventListener("resize", () => {
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;
            if (settings.layoutMode === 'force') {
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }
            simulation.alpha(0.1).restart();
        });
    </script>
</body>
</html>
